package shell

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"workspaced/pkg/common"
	"workspaced/pkg/prelude"

	"github.com/spf13/cobra"
)

func getInitCommand() *cobra.Command {
	var force bool

	cmd := &cobra.Command{
		Use:   "init [shell]",
		Short: "Generate shell initialization script",
		Long: `Generates shell initialization by concatenating prelude scripts.
Uses caching for performance - regenerates only when source files change.`,
		Args: cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			shell := "bash"
			if len(args) > 0 {
				shell = args[0]
			}

			// Find dotfiles root
			dotfilesRoot, err := findDotfilesRoot()
			if err != nil {
				return fmt.Errorf("failed to find dotfiles root: %w", err)
			}

			preludeDir := filepath.Join(dotfilesRoot, "bin", "prelude")

			// Get cache path
			cacheDir := getCacheDir()
			if err := os.MkdirAll(cacheDir, 0755); err != nil {
				return fmt.Errorf("failed to create cache directory: %w", err)
			}

			buildID := common.GetBuildID()
			cacheFile := filepath.Join(cacheDir, fmt.Sprintf("shell-init-%s-%s.bash", shell, buildID))

			// Check if cache exists (build ID already in filename)
			if !force {
				if content, err := os.ReadFile(cacheFile); err == nil {
					fmt.Print(string(content))
					return nil
				}
			}

			// Read all prelude files in parallel
			allFiles, err := filepath.Glob(filepath.Join(preludeDir, "*.sh"))
			if err != nil {
				return fmt.Errorf("failed to list prelude files: %w", err)
			}

			// Separate .source.sh files from regular .sh files
			var files []string
			sourceFiles := make(map[string]string) // basename -> path

			for _, file := range allFiles {
				basename := filepath.Base(file)
				if strings.HasSuffix(basename, ".source.sh") {
					// Map the base name without .source.sh extension
					key := strings.TrimSuffix(basename, ".source.sh")
					sourceFiles[key] = file
				} else {
					files = append(files, file)
				}
			}
			sort.Strings(files)

			// Read all files in parallel
			type fileContent struct {
				path    string
				content string
				err     error
			}

			results := make(chan fileContent, len(files))
			var wg sync.WaitGroup

			for _, file := range files {
				wg.Add(1)
				go func(path string) {
					defer wg.Done()
					content, err := os.ReadFile(path)
					results <- fileContent{
						path:    path,
						content: string(content),
						err:     err,
					}
				}(file)
			}

			// Wait and close results channel
			go func() {
				wg.Wait()
				close(results)
			}()

			// Collect results maintaining order
			contentMap := make(map[string]string)
			for result := range results {
				if result.err != nil {
					return fmt.Errorf("failed to read %s: %w", result.path, result.err)
				}
				contentMap[result.path] = result.content
			}

			// Execute .source.sh files in parallel
			sourceOutputs, err := executeSourceFiles(sourceFiles)
			if err != nil {
				return fmt.Errorf("failed to execute source files: %w", err)
			}

			// Build output in order
			var output strings.Builder
			output.WriteString("# Generated by workspaced shell init\n")
			output.WriteString("# This file is cached for performance\n")
			output.WriteString("# Commands executed in parallel for faster loading\n\n")

			// Generate all inline prelude code in parallel
			inlineCode, err := prelude.Generate()
			if err != nil {
				return fmt.Errorf("failed to generate inline prelude: %w", err)
			}
			output.WriteString(inlineCode)

			for _, file := range files {
				basename := filepath.Base(file)
				baseKey := strings.TrimSuffix(basename, ".sh")

				// Skip files generated inline above
				if strings.Contains(basename, "workspaced-init") ||
				   strings.Contains(basename, "workspaced-history") {
					continue
				}

				// Check if there's a .source.sh file - if so, use ONLY its output
				if sourceOutput, hasSource := sourceOutputs[baseKey]; hasSource {
					output.WriteString(fmt.Sprintf("# Source: %s (generated by %s.source.sh)\n", basename, baseKey))
					output.WriteString(sourceOutput)
					if !strings.HasSuffix(sourceOutput, "\n") {
						output.WriteString("\n")
					}
					output.WriteString("\n")
					continue
				}

				// Regular file processing
				content := contentMap[file]
				output.WriteString(fmt.Sprintf("# Source: %s\n", basename))
				output.WriteString(content)

				if !strings.HasSuffix(content, "\n") {
					output.WriteString("\n")
				}
				output.WriteString("\n")
			}

			result := output.String()

			// Save to cache
			if err := os.WriteFile(cacheFile, []byte(result), 0644); err != nil {
				// Non-fatal, continue
				fmt.Fprintf(os.Stderr, "Warning: failed to write cache: %v\n", err)
			}

			fmt.Print(result)
			return nil
		},
	}

	cmd.Flags().BoolVarP(&force, "force", "f", false, "Force regeneration, ignore cache")

	return cmd
}

func findDotfilesRoot() (string, error) {
	// Try common locations
	home := os.Getenv("HOME")
	locations := []string{
		filepath.Join(home, ".dotfiles"),
		"/etc/.dotfiles",
	}

	for _, loc := range locations {
		if info, err := os.Stat(filepath.Join(loc, "bin", "prelude")); err == nil && info.IsDir() {
			return loc, nil
		}
	}

	return "", fmt.Errorf("dotfiles root not found")
}

func getCacheDir() string {
	if xdgCache := os.Getenv("XDG_CACHE_HOME"); xdgCache != "" {
		return filepath.Join(xdgCache, "workspaced")
	}
	return filepath.Join(os.Getenv("HOME"), ".cache", "workspaced")
}

// generateColorCodes generates ANSI color codes inline without calling external commands

// executeSourceFiles executes all .source.sh files in parallel and returns their outputs
func executeSourceFiles(sourceFiles map[string]string) (map[string]string, error) {
	if len(sourceFiles) == 0 {
		return make(map[string]string), nil
	}

	type sourceResult struct {
		key    string
		output string
		err    error
	}

	results := make(chan sourceResult, len(sourceFiles))
	var wg sync.WaitGroup

	for key, path := range sourceFiles {
		wg.Add(1)
		go func(k, p string) {
			defer wg.Done()

			// Execute the source file with bash
			cmd := exec.Command("bash", p)
			cmd.Env = os.Environ()
			output, err := cmd.Output()

			results <- sourceResult{
				key:    k,
				output: string(output),
				err:    err,
			}
		}(key, path)
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	// Collect results
	outputMap := make(map[string]string)
	for result := range results {
		if result.err != nil {
			// Log warning but don't fail - just skip this source file
			fmt.Fprintf(os.Stderr, "Warning: failed to execute %s.source.sh: %v\n", result.key, result.err)
			continue
		}
		outputMap[result.key] = result.output
	}

	return outputMap, nil
}
