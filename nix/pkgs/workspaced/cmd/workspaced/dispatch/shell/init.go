package shell

import (
	"crypto/sha256"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"

	"github.com/spf13/cobra"
)

func getInitCommand() *cobra.Command {
	var force bool

	cmd := &cobra.Command{
		Use:   "init [shell]",
		Short: "Generate shell initialization script",
		Long: `Generates shell initialization by concatenating prelude scripts.
Uses caching for performance - regenerates only when source files change.`,
		Args: cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			shell := "bash"
			if len(args) > 0 {
				shell = args[0]
			}

			// Find dotfiles root
			dotfilesRoot, err := findDotfilesRoot()
			if err != nil {
				return fmt.Errorf("failed to find dotfiles root: %w", err)
			}

			preludeDir := filepath.Join(dotfilesRoot, "bin", "prelude")

			// Get cache path
			cacheDir := getCacheDir()
			if err := os.MkdirAll(cacheDir, 0755); err != nil {
				return fmt.Errorf("failed to create cache directory: %w", err)
			}

			cacheFile := filepath.Join(cacheDir, fmt.Sprintf("shell-init-%s.bash", shell))
			hashFile := filepath.Join(cacheDir, fmt.Sprintf("shell-init-%s.hash", shell))

			// Read all prelude files in parallel
			files, err := filepath.Glob(filepath.Join(preludeDir, "*.sh"))
			if err != nil {
				return fmt.Errorf("failed to list prelude files: %w", err)
			}
			sort.Strings(files)

			// Calculate hash of all files
			currentHash, err := calculateFilesHash(files)
			if err != nil {
				return fmt.Errorf("failed to calculate hash: %w", err)
			}

			// Check if cache is valid
			if !force {
				if cachedHash, err := os.ReadFile(hashFile); err == nil {
					if string(cachedHash) == currentHash {
						// Cache is valid, return cached content
						content, err := os.ReadFile(cacheFile)
						if err == nil {
							fmt.Print(string(content))
							return nil
						}
					}
				}
			}

			// Read all files in parallel
			type fileContent struct {
				path    string
				content string
				err     error
			}

			results := make(chan fileContent, len(files))
			var wg sync.WaitGroup

			for _, file := range files {
				wg.Add(1)
				go func(path string) {
					defer wg.Done()
					content, err := os.ReadFile(path)
					results <- fileContent{
						path:    path,
						content: string(content),
						err:     err,
					}
				}(file)
			}

			// Wait and close results channel
			go func() {
				wg.Wait()
				close(results)
			}()

			// Collect results maintaining order
			contentMap := make(map[string]string)
			for result := range results {
				if result.err != nil {
					return fmt.Errorf("failed to read %s: %w", result.path, result.err)
				}
				contentMap[result.path] = result.content
			}

			// Build output in order
			var output strings.Builder
			output.WriteString("# Generated by workspaced shell init\n")
			output.WriteString("# This file is cached for performance\n\n")

			for _, file := range files {
				content := contentMap[file]
				output.WriteString(fmt.Sprintf("# Source: %s\n", filepath.Base(file)))
				output.WriteString(content)
				if !strings.HasSuffix(content, "\n") {
					output.WriteString("\n")
				}
				output.WriteString("\n")
			}

			result := output.String()

			// Save to cache
			if err := os.WriteFile(cacheFile, []byte(result), 0644); err != nil {
				// Non-fatal, continue
				fmt.Fprintf(os.Stderr, "Warning: failed to write cache: %v\n", err)
			}
			if err := os.WriteFile(hashFile, []byte(currentHash), 0644); err != nil {
				// Non-fatal, continue
				fmt.Fprintf(os.Stderr, "Warning: failed to write hash: %v\n", err)
			}

			fmt.Print(result)
			return nil
		},
	}

	cmd.Flags().BoolVarP(&force, "force", "f", false, "Force regeneration, ignore cache")

	return cmd
}

func findDotfilesRoot() (string, error) {
	// Try common locations
	home := os.Getenv("HOME")
	locations := []string{
		filepath.Join(home, ".dotfiles"),
		"/etc/.dotfiles",
	}

	for _, loc := range locations {
		if info, err := os.Stat(filepath.Join(loc, "bin", "prelude")); err == nil && info.IsDir() {
			return loc, nil
		}
	}

	return "", fmt.Errorf("dotfiles root not found")
}

func getCacheDir() string {
	if xdgCache := os.Getenv("XDG_CACHE_HOME"); xdgCache != "" {
		return filepath.Join(xdgCache, "workspaced")
	}
	return filepath.Join(os.Getenv("HOME"), ".cache", "workspaced")
}

func calculateFilesHash(files []string) (string, error) {
	h := sha256.New()

	for _, file := range files {
		// Include filename in hash
		if _, err := h.Write([]byte(file)); err != nil {
			return "", err
		}

		// Include file content
		f, err := os.Open(file)
		if err != nil {
			return "", err
		}
		if _, err := io.Copy(h, f); err != nil {
			f.Close()
			return "", err
		}
		f.Close()
	}

	return fmt.Sprintf("%x", h.Sum(nil)), nil
}
